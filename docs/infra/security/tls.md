# TLS

## TLS(Transport Layer Security)とは？

- 暗号化、認証のためのプロトコル
- 元々は SSL(Secure Sockets Layer)という名前だったが、バージョンアップを重ねた後、SSL3.0 を元に TLS（Transport Layer Security）1.0 が RFC として定められた
- その後、TLS が一般的に使われるようになったが、昔の名残で TLS のことを SSL や SSL/TLS と言ったりもする

## 秘密鍵と公開鍵

- 秘密鍵と公開鍵はペアで作られる
  - 秘密鍵は特定の機器上にのみ持ち原則公開をしないもの
  - 公開鍵は広く公開するためのもの
- 暗号複合での用途
  - 公開鍵は暗号化するためのもの、秘密鍵は複合するためのもの
  - RSA など秘密鍵で暗号し公開鍵で複合することもできるものもある
    - しかし、すべての公開鍵・秘密鍵がこの特性を持ってるわけではないので注意
- デジタル署名での用途
  - 秘密鍵は署名するためのもの、公開鍵は署名が正しいかを検証するためのもの
  - 署名と検証は秘密鍵による暗号化と公開鍵による複合が必要となる

## ハッシュ関数によりデータが改ざんされていないことを保証するということ

- ハッシュ関数は、任意の入力データから固定の値を得るための関数
  - この値をダイジェスト（もしくはハッシュ値）と呼ぶ
- このダイジェストが変わらないことでデータが改ざんされていないことを保証できる

```
$ echo hoge > hoge
$ md5sum hoge
c59548c3c576228486a1f0037eb16a1b  hoge

$ echo piyo > hoge
$ md5sum hoge
5ac5ee93bec2a712250aefed8f7568e7  hoge
```

## MAC（メッセージ認証コード）

- MAC（メッセージ認証コード）では署名と検証するための鍵が同じ
- 入力データと秘密鍵（適当な文字列でよい）をハッシュ関数に通して、ダイジェストを生成する
  - このダイジェストが署名となる
- この署名が正しいかを検証するには、入力データと秘密鍵をハッシュ関数に通して、生成されたダイジェストが署名と一致すれば改ざんされていないことを証明できる
  - この証明ができるのは秘密鍵を知っているもののみである

## デジタル署名(電子署名)

- 一般的なデジタル署名は特殊な公開鍵・秘密鍵を用いるもので、秘密鍵で署名し、公開鍵で検証する
  - 特殊な公開鍵・秘密鍵というのは、RSA のように秘密鍵で暗号化し、公開鍵で複合できる必要があるということ
  - ここで重要なのは秘密鍵をもっている本人のみが署名を作れることを保証し、公開鍵を持ってる人が（誰でも）署名の検証ができるということ
    - その手段として、秘密鍵で暗号、公開鍵で複合できると、これが満たせる
- デジタル署名を含むデータ送信の流れ
  - データ送信側: 秘密鍵と公開鍵のペアを作る
  - データ送信側: 何らかの方法で相手に公開鍵を送信する
  - データ送信側: 対象データを用意する
  - データ送信側: 対象データをハッシュ関数でダイジェストを生成し、これを秘密鍵で暗号化する（これがデジタル署名)
    - ダイジェストを生成するのは、データ長を短い固定長にするため（計算コストを下げる目的がある）
  - データ送信側: 対象データと署名を相手に送信する
  - データ受信側: 公開鍵を用いて、デジタル署名を複合する
  - データ受信側: 対象データのダイジェストと、複合された署名が一致することを確認する
- 以上の流れにより、データが改ざんされていないこと、データの送信者が公開鍵の秘密鍵を所持していることを保証できる

```
# 秘密鍵の作成
$ openssl genrsa -out private-key.pem

# 公開鍵の作成
$ openssl rsa -in private-key.pem -pubout -out public-key.pem

# 対象データを用意
$ echo hoge > hoge

# 秘密鍵により署名を作成
$ openssl dgst -sha1 -sign private-key.pem hoge > sign.sig

# 公開鍵により署名を検証
$ openssl dgst -sha1 -verify public-key.pem -signature sign.sig hoge
Verified OK

# 公開鍵により署名を検証(NG例)
$ openssl dgst -sha1 -verify public-key.pem -signature sign.sig piyo
Verification Failure
```

## CSR と証明書チェーン

- CSR(Certificate Signing Request)
  - 認証局(第三者)に公開鍵の証明書を発行してもらうためのリクエスト
  - サービス提供者は、CSR を用いて事前に認証局から証明書を発行してもらう
  - ある公開鍵を証明するための認証局とは別に、その認証局の公開鍵を証明するための認証局も存在する
- 証明書チェーンは公開鍵を本物かどうかを検証するための仕組み
- 事前準備
  - サービス提供者 A は、認証局 B に A の公開鍵の証明書(サーバ証明書)を発行してもらう
    - 証明書には以下の情報が含まれる
      - 主体者: A
      - 発行者: B
      - 公開鍵: A の公開鍵
      - 署名: B によるデジタル署名
  - 認証局 B は、認証局 C に B の公開鍵の証明書(中間証明書)を発行してもらう
    - 証明書には以下の情報が含まれる
      - 主体者: B
      - 発行者: C
      - 公開鍵: B の公開鍵
      - 署名: C によるデジタル署名
  - 認証局 C は、自身の公開鍵の証明書(ルート証明書)を発行しておく
    - 証明書には以下の情報が含まれる
      - 主体者: C
      - 発行者: C
      - 公開鍵: C の公開鍵
      - 署名: C によるデジタル署名
    - ルート証明書は主体者と発行者が同じである
    - 主要なブラウザや OS には事前にルート証明書がインストールされているため、クライアントは何もせずともルート証明書を所持している
      - またルート証明書は、OS のアップデートやブラウザのアップデート時に自動で更新される
    - また、独自のルート証明書を利用する場合は、独自にそのルート証明書をブラウザや OS にインストールする必要がある
- 証明書チェーンの流れ
  - サーバはクライアントに A のサーバ証明書を送信する
    - サーバ証明書の署名は B によってなされたもので、これを検証するためには B の公開鍵が必要となる
  - 認証局 B の公開鍵付きの証明書をもらう
    - この証明書の署名は C によってなされたもので、これを検証するためには C の公開鍵が必要となる
  - C の公開鍵はルート証明書としてあらかじめインストールされているので、証明書の検証ができる
  - 以上の流れにより、サーバ証明書に含まれる A の公開鍵の妥当性を証明することができる
  - このようなサーバ証明書の妥当性を検証するまでを証明書チェーンと呼ぶ
- 証明書チェーンによってサーバ証明書の認証が完了すれば、クライアントはその公開鍵を使って目的のデータを暗号化してサーバにデータを送信することができる
  - この暗号化されたデータを複合できるのは当然秘密鍵を持ったサーバのみである
- 補足としてサーバ証明書を管理するのは厳密にはサーバではない
  - 正しくは、クライアントと TLS を実際に終端するもの(直接コネクションを確立するもの)が管理する
  - サーバが管理する場合もあるし、インラインロードバランサが管理する場合もあし、また SSL-VPN では、VPN のゲートウェイが管理する
- サーバ証明書の有効期限について
  - サーバ証明書にはその有効期限を設定することができる
  - ブラウザによってはサーバ証明書の有効期限が長すぎると警告が出たり、はじかれる場合があるため、有効期限は 1 年以内にすることが推奨とされている
    - これは Safari が 2020 年 9 月より、それ以降に発行されたサーバ証明書において有効期限が 399 日以上のサーバ証明書を信頼できないものと表示するようにしたため
  - 公開鍵からも膨大な時間を掛ければ秘密鍵を推測することは可能なため、証明書は定期的に更新し続けるべきである
  - ただし、公開鍵を不特定多数に公開していない場合、例えばプライベートなネットワーク空間や開発環境で利用している場合は、多少長くしてもよしとされている
    - とはいえ、証明書の定期更新の仕組みは今や必須である

## HTTPS

- HTTPS コネクションの確立時の流れ
  - クライアントが https のサーバにアクセスしたときに、SSL 暗号化通信で接続を要求する
  - サーバは、自身を証明するサーバ証明書をクライアントに送る
  - クライアントは証明書チェーンにより、サーバ証明書が正しいことを確認する
  - クライアントはサーバ証明書に含まれる公開鍵を使って、プライマスタシークレットを暗号化してサーバに送信する
    - プライマスタシークレットとは共通鍵を生成する元となる乱数データのこと
      - これによりクライアントは共通鍵を生成する
  - サーバは暗号化されたプライマスタシークレットを複合化し、共通鍵を生成する
  - 以降のセッションは共通鍵によって暗号化された通信経路上で行われる

## X.509 証明書

- デジタル証明書のデータ形式を定めた規格の一つ
- 証明書のデータ表現
  - 証明書の構造は、[RFC 5280](https://tools.ietf.org/html/rfc5280) で定められている
  - ASN.1 で定義されているが、ASN.1 自体はデータ構造を抽象的に表現するための記法なので、この定義だけでは具体的にどのようなバイト配列にデータを落とし込めばよいのかは定まらない
  - 具体的なバイト配列に落とし組むための技術仕様が別途必要となり、これは以下などがある
    - DER(Distinguished Encoding Rules)
    - XER(XML Encoding Rules)
    - JER(JSON Encoding Rules)
  - DER などでバイト配列に落とし込んだらこのまま使ってもよいが、この後に、BASE64(RFC 4648)などのデータ形式に変換することもある
  - さらに、BASE64 でテキストデータになったら、これを PEM(RFC 7468) という形式でデータ修飾してもよい
    - PEM は、data を ----BEGIN CERTIFICATE---- data -----END CERTIFICATE----- でくくったやつ
    - よく見かける証明書ファイルは人が読みやすいよう PEM で吐き出される
- 主体者識別子
  - Subject: ホスト名で主体者をしていするためのもの
  - SubjectAlternativeName: ホスト名以外で主体者名を指定するためのもの

## TLS サーバ証明書(サーバ ID)

- 大きく分けてドメイン名認証型と企業認証型の２つがある
  - ドメイン名認証型(DV)
    - ドメインの所有者と証明発行を申し込んできた運営者が同一であることを確認してから発行される
    - 身元確認はしないので、実在性は証明しない
  - 企業認証型(OV)
    - DV の確認に加えて、帝国データバンクや登記事項証明書の確認、電話による申請者の在籍・役職と申請の意思確認などが行われから発行される
  - 企業認証型(EV)
    - OV の確認に加えて、事業所の実在性の確認と事業所への申請責任者確認書の送付・返送が必要などが行われてから発行される
- TLS 証明書は認証局に発行してもらうものだが、独自にサーバ証明書を発行することもできる
- TLS 証明書の信頼性は、EV > OV > DV > 独自 となる
- TLS 証明書には、以下のような情報が含まれる
  - 公開鍵
  - 有効期限
  - Subject: CommonName
    - サーバのホスト名を設定する(必須)
    - クライアントがアクセスした際に URL と、Subject が一致しているかを検証します
  - Subject: Alt Name
    - Subject の別名を複数設定できる(オプション)
  - Server Certificate:
    - その証明書を発行した認証局の証明書、さらに上位の認証局があればそれも（ルート証明書までの証明書チェーン)を含む

## 自己証明書の作成

- [cfssl](https://github.com/cloudflare/cfssl)
  - 使用例: [Provisioning a CA and Generating TLS Certificates](https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/master/docs/04-certificate-authority.md)

## CAA レコード

- SSL/TLS 証明書の発行を許可する認証局を、ドメインの所有者が宣言するためのレコード
- 認証局は、証明書発行の際に、subjectAltName に記載されたドメインすべての CAA レコードをチェックすることが義務付けられており、証明書の不正発行や誤発行を防ぐ役割がある

```
;; ANSWER SECTION:
google.com.             86400   IN      CAA     0 issue "pki.goog"

;; ANSWER SECTION:
yahoo.co.jp.            900     IN      CAA     0 issue "globalsign.com"
yahoo.co.jp.            900     IN      CAA     0 issue "digicert.com;cansignhttpexchanges=yes"
yahoo.co.jp.            900     IN      CAA     0 iodef "mailto:nic-admin@mail.yahoo.co.jp"
yahoo.co.jp.            900     IN      CAA     0 issue "cybertrust.ne.jp"
```
