# ネットワーク基礎

## OSI 参照モデル

- OSI は、Open System Interconnection の略
- アプリケーション層(L7)
  - それぞれのアプリケーションの中での通信に関するプロトコルを定める
  - HTTP, FTP, DHCP, NTP, SMTP などのプロトコルがこれにあたる
- プレゼンテーション層(L6)
  - 文字のエンコード方式や圧縮方式、暗号方式などのデータフォーマット(表現:プレゼンテーション)を定める
  - 文字のエンコード方式は UTF-8、Shift_JIS など
  - 画像の圧縮形式であれば、JPEG、MPEG など
- セッション層(L5)
  - アプリケーションレベルでの送受信(request, response)による通信の接続を管理する
  - HTTP セッションなどがこれにあたる
- トランスポート層(L4)
  - データ転送を行うための論理的な通信プロトコル
  - TCP, UDP などがこれにあたる
  - TCP は、TCP セッションを持ち信頼性のある通信が行える
  - UDP は、セッションレスであり信頼性は低いが低レイテンシの通信が行える
- ネットワーク層(L3)
  - IP アドレスの管理や経路の選択を行い、宛先までデータを届けるプロトコル
  - IP や ICMP がこれにあたる
    - IP でのアドレスを単に IP アドレスと呼ぶ
- データリンク層(L2)
  - 物理的(もしくは無線的)に隣同士で接続された機器間での通信
  - 一つの伝送路をリンクと呼ぶ
  - 0 と 1 のビット列からなるデータをフレームと呼ぶ
  - 通信手順を定める規格には様々なものがある
    - Ethernet(IEEE 802.3)
      - オフィスや一般家庭などで一般的によく利用される優先 LAN における通信規格
    - PPP(Point-to-Point Protocol)
    - PPTP(Point-to-Point Tunneling Protocol)
      - VPN(Virtual Private Network)で用いられる
    - L2TP(Layer 2 Tunneling Protocol)
  - Ethernet では MAC(Medium Access Control: 媒体アクセス制御) によって、通信制御が行われる
    - MAC でのアドレスを単に MAC アドレスと呼ぶ
- 物理層(L1)
  - 情報ビット列を電気や光の信号に変換し、同軸ケーブルや光ファイバーといった媒体を返しての通信層
  - LAN ケーブルでよく目にする 10BASE-T や 100BASE-TX などが物理層の規格
- コラム
  - 各層の事を呼ぶときは省略して L1, L2,..,L7 と呼ぶことが多い
  - 基本的にアプリケーション層からセッション層はアプリケーションによって実装されるため、これらをまとめて単にアプリケーション層(L7)と言うこともよくある
  - パケットとフレームについて
    - パケットは厳密にはすべてのレイヤで使われるデータ単位として使われる一般的な用語
      - L4 でも、L3 でも、L2 でもそのデータ単位をパケットと呼ぶ
    - フレームは L2 でのパケットのこと
    - しかし、一般的にはパケットとフレームは同じものを指して使われることが多い
    - PPS(Packets Per Sec)という言葉も、基本的に L2 でのパケット（つまりフレーム)のことを指す

## RFC

- Request For Comments の略
- IETF(Internnet Engineering Task Force)が発行している技術仕様群
- 明確な規格というよりかは、規格を提案する場という意味合いがある
  - 規格考えたからコメント求むというニュアンス
- TCP, IP などのほぼすべてのプロトコル仕様はここに記載され日々議論されている

## 階層モデルにおけるデータフレームのフォーマット

- 最終的な通信データのフレームは L2 で完成する
- 1 フレームは、アプリケーションで扱いたいデータに加え、L4, L3, L2 の各層それぞれで必要となる情報をヘッダとして付与して完成する
  - TCP ではデータの順序番号や再送制御に関する情報がヘッダに入ってる
  - IP であれば IP アドレスの情報などがヘッダに入ってる
  - 一般的にイーサネットフレームの最大値(MTU)は 1500 バイト
    - このうち TCP ヘッダが 20-60 バイト、IP ヘッダが 20 バイト、アプリケーション層では 1420 バイト
    - また TCP における TCP ヘッダを含めないデータ単位の事をセグメントとよび、その最大のことを MSS(Maximum Segment Size)と呼ぶ
      - MTU1500 の場合は、TCP ヘッダの最小 20 と IP ヘッダの最小を引いた 1460 が MSS となる
  - これに加えてイーサネットのヘッダー 14 バイトとフレーム末尾に付与される誤り検出のための FCS(Frame Check Sequence)4 バイトが付与されて一つのフレームが完成
    - つまり MTU1500 の場合の最大フレームサイズは 1518 バイトとなる
- L2 と L3 の対応付け
  - L3 でルーティングした後に最終的な宛先へ L2 でパケットを転送することとなる
  - このため、IP アドレスと MAC アドレスの対応関係が必要になる
  - この対応関係を ARP Table と呼び、ARP(Address Resolution Protocol: アドレス解決プロトコル)により事前に作成される
- データ転送は各機器ごとに必要となる階層でのみ処理を行えばよい

## IP フラグメンテーションと PMTUD(Path MTU Discovery)

- MTU は各ネットワーク機器で設定されており、送信者は途中経路のネットワーク機器の MTU を考慮してパケット分割する必要がある
- もし、送信したパケットがルータの MTU よりも大きい場合はそのパケットは分割される（これを IP フラグメンテーションと呼ぶ）
- しかし、IPv4 パケットに DF(Don't Fragment)フラグが設定されている場合は、IP フラグメンテーションは起こらず、ルータはそのパケットをドロップして、ICMP で送信元に知らせる(fragmentation needed and DF set)
- このとき、送信元は PMTUD を実施して、途中経路の MTU を検索する
- これは基本的には ICMP によって行われる、しかし ICMP では ECMP を利用された場合に正しく MTU の解決ができない場合があり TCP で行われる場合もある（明示的に設定する必要がある）
- PMTUD が成功するとその結果はキャッシュされて、以降はキャッシュされた MTU でパケットを分割して送信することになる
- IP フラグメンテーションが起こると
  - IP パケットは MTU に収まるように分割される
    - ここで考慮すべきなのは、IP の Payload に含まれる L4 のヘッダ(TCP ヘッダなど)は先頭のパケットのみに含まれ、以降のパケットには含まれない
    - もし 5-tupple でトラフィックフローをコントロールしてる場合、それができなくなる
      - ステートレスファイアウォールやステートレスロードバランサはフローの識別に 5-tupple を利用してることが多く、これを考慮する必要がある
  - フラグメントされたパケットは、受信側で再構成する必要がある（コスト大）
    - IP パケットのヘッダに、フラグメントの情報が格納されているのでこれを頼りに再構成する
- IPv6 では、この問題は軽減化されており、ルーターなどの中間デバイスではパケットのフラグメント化はできなくなっている
  - しかし、送信元ではフラグメント化できるので完全に解決はできてない
  - IPv6 の Flow ラベル
    - Flow ラベルがあるとトランスポート層が利用できない場合でも Flow を特定できる可能性がある
    - しかし、Flow ラベルは必ず設定されるわけではない（利用されない場合は 0 がセットされる）
      - 仕様でも転送ノードは Flow ラベルに頼ってはいけないとされ、5-tupple も併用する必要がある
    - ファイアウォールやロードバランサによって書き換えられる可能性があったり、他の用途で利用される可能性もある
- 参考
  - [What is a Network Traffic Flow? (Part 2)](https://mattjhayes.com/2018/10/21/what-is-a-network-traffic-flow-part-2/)

## ネットワークの輻輳

- ネットワーク機器には単位時間あたりに伝送可能なデータ量に限りがある
- ネットワーク機器は受信バッファを持っており、これを超えるデータを受信するとその分のデータは破棄される(overflow)
- また、データが同時にしたこと(衝突)によってデータが破損することもある
- このような状況を輻輳と呼ぶ
- TCP や QUIC などは、輻輳制御によりこのようなネットワーク状況を考慮し、データ破損などがあればネットワークが輻輳してるとみなして通信データ量を減らしたりする
- 一方で UDP にはこのような仕組みがないので UDP を使う場合は、アプリケーション自体にそのような制御機構がないとネットワーク輻輳の原因となる可能性がある

## UDP

- チェックサム
  - データ破損がないかチェックする機構
- UDP で信頼性を確保するために L7 で制御するプロトコルもある
  - RTP(Real-time Transport Protocol)
    - UDP にシーケンス番号やタイムスタンプ機能を追加したもの
  - RUDP(Reliable User Datagram Protocol)
    - RTP にシーケンス番号の確認応答、再送機能を追加したもの
  - DCCP(Datagram Congestion Control Protocol)
    - UDP における輻輳の緩和を目的として考案されたもの
  - QUIC(Quick UDP Internet Connections)
    - HTTP を UDP で実現したもので、信頼確保や輻輳制御なども L7 で行われる
    - QUIC は、2012 年に Google のエンジニアが提案した L4 のプロトコル仕様が発端となった
      - 初期の仕様は Google-QUIC、gQUIC と呼ばれ、Chrome など実験的に使われてきた
    - この QUIC 上で HTTP を動かす規格を HTTP/3 と呼ぶ

## TCP

- データの転送単位をセグメントと呼ぶ
- チェックサム
  - データ破損がないかチェックする機構
- コネクション管理
  - データと ACK をやりとりすることで信頼性を保証する
  - シーケンス番号
    - セグメントの順番を保証し、またその消失を検出するために利用される
    - シーケンス番号は通信データを 1 バイト単位でカウントしたもの
    - 送信側は、データを送信するときにシーケンス番号を付与して送信する
    - 受信側は、データを受信したら、その次に受信したいシーケンス番号を ACK に格納して送信側に返す
      - シーケンス番号が 3001 で 1000 バイトのデータを受信したら、受信側は 4000 までのシーケンス番号のデータを受け取ったということ
      - 受信側は ACK に 4001 のシーケンス番号を付与して、送信側に返す
      - 送信側は、該当するセグメントから MSS 分のデータを送信する
        - MSS は 3WayHandShake によって通知される
        - MSS は MTU から逆算されて求められる
        - MSS の単位で TCP のペイロードを分割することを TCP セグメンテーションと呼ぶ
        - MTUD が(ICMP を禁止してるなどで)正しく行われていなくても、この仕組みのおかげで IP フラグメンテーションが発生しない場合もある
- コネクションの確立(3WayHandShake)
  - 以下の 3 つの手順により TCP コネクションを確立すること
    - クライアント側からサーバ側に Syn(SYN=1, ACK=0)を送る
      - シーケンス番号は、ランダム(111 とする)
    - サーバ側はクライアント側に SynAck(SYN=1, ACK=1)を送る
      - シーケンス番号は、ランダム(222 とする)
      - 確認応答番号は、相手から送られた Syn のシーケンス番号に 1 を加算した値(112)
    - クライアント側はサーバ側に Ack(SYN=0, ACK=1)を送る
      - シーケンス番号は、サーバ側から送られた確認応答番号(112)
      - 確認応答番号は、相手から送られた SynAck のシーケンス番号に 1 を加算した値(223)
- コネクションの切断(HalfClose)
  - 以下の手順により TCP コネクションを切断する
    - 送信側は最初に FIN を送信
    - 受信側は ACK を送信し、その次に FIN も送信する
    - 送信側は FIN を受信したらその ACK を返す
      - 一定時間待ってコネクションを終了する
  - 送信側のクローズ処理をアクティブクローズと呼ぶ
  - 受信側のクローズ処理をパッシブクローズと呼ぶ
- 再送
  - 再送タイマーを利用する方法
    - TCP ではセグメントを送信してからそれに対応する ACK が返答されるまでの時間を RTT(Round Trip Time, 往復遅延時間)として計測している
    - この RTT よりもやや大きい時間を RTO(Retransmission Time Out, 再送タイムアウト)として算出しておく
    - 送信したシーケンス番号のセグメントに対してタイマーをセットし、これに対応する ACK が RTO を経過しても届かないのであれば、該当セグメントは消失したものとして再送を行う
  - ACK を利用する方法
    - 受信側は次に受け取るべきシーケンス番号を ACK に付与して送信側に返すが、これは該当セグメントが届くまで同じシーケンス番号を記載した ACK を返送し続ける
    - 送信側は同じシーケンス番号を記載した ACK を複数回(3 回)受信した場合、該当セグメントを焼失したと判断し、再送を行う
- フロー制御
  - 受信側が受信バッファが溢れないように許容可能なデータ量を送信側に通知して、送信側に送信データ量を調整する制御のことをフロー制御と呼ぶ
  - TCP では、送信側が一度に送信可能なデータの枠をウィンドウとよび、その大きさをウィンドウサイズと呼ぶ
    - 送信側は、swnd(send window)というパラメータでこれを指定する
  - 受信側は、受信可能なデータ量を受信ウィンドウサイズ(rwnd: receive window)というパラメータで、送信に通知する
  - 送信側はこの rwnd を超えないように送信するデータ量を調整する
  - 受信バッファがあふれたときの挙動
    - 受信側で TCP の受信バッファの空きがなくなると、送信側に rwnd==0 でパケットを返す(TCP ZeroWindow)
    - 送信側は、rwnd==0 のパケットを受信すると、受信側に対する送信を一時停止する
    - 送信側は、一定時間後に再度チェックとして、TCP ZeroWindowProbe を送信する
    - 受信側は、受信バッファの空きがあれば、rwnd で教えるが、ない場合はまた rwnd==0 で Ack を返す(TCP ZeroWindowProbeAck)
    - 送信側は、これが続く場合にはリセットを送信してそのコネクションを切断する
- 輻輳制御
  - 輻輳制御アルゴリズムに基づきネットワークの輻輳を判断し、送出するデータ量を調整する
  - 輻輳ウィンドウサイズ(cwnd: congestion window)というパラメータでデータ量を調整する
    - swnd は rwnd と cwnd に基づいて決定される
      - 基本的にはこれらのうち小さいほうが優先される
  - Loss-based 輻輳制御
    - データの消失からネットワークの輻輳を判断する
    - 基本的には以下
      - ACK を受け取った後に、次のデータを送る
      - 一度に送信するデータ量を徐々に増加させていく(スロースタート)
      - データ消失を検知したら、送出量を減らす
    - このようにウィンドウサイズを増減させながらデータを転送していく方式を「スライディングウィンドウ」という
    - Tahoe
      - 初期の TCP アルゴリズム
      - スロースタート、輻輳回避、高速再転送
    - Reno
      - Tahoe に高速リカバリを追加したもの
    - NewReno
      - Reno を改良し、高速リカバリ段階において複数の消失セグメントの再送に対応したバージョン
  - Delayed-based 輻輳制御
    - RTT 用いてネットワークの輻輳を判断する
    - Vegas
      - RTT の変動をもとに混雑量を予測し転送量を調整するアルゴリズム - BBR(Bottleneck Bandwidth and Round-trip propagation time) - Google が 2016 年に発表し、Linux4.9 以降で利用可能となった - 思想的にはバッファ遅延を発生させないようにはするが、データネットワークの帯域はフルで利用することを目指している
  - Hybrid 輻輳制御
    - Loss-based と Delayed-based の両者を取り入れた方法
    - BIC(Binary Increase Congestion control)
      - 2004 年に発表され、Linux2.6.8 まで使われてきた
      - 安定性、スケーラビリティ、RTT 公平性という特徴を持ち CUBIC のベースとなるアルゴリズム
    - CUBIC
      - BIC の改良版で、Linux2.6.18 で BIC からこれに置き換えられ利用されている
- Multipath TCP(mptcp)
  - Linux5.6 から利用可能になった、iOS11 以降でも利用できる
  - 複数インターフェイスを使って TCP コネクションをはって通信を行う

## ポート番号

- TCP, UDP ともに番号を持っており、ポート番号からどのアプリケーションの通信かを判断し、ソケットを介してアプリケーションとデータのやり取りを行う
- ポート番号には以下の種類がある
  - 0-1023 の範囲のポートは、ウェルノウンポートと呼ばれ、一般的なアプリケーションで利用される予約済みのポートである
  - 1024–49151 の範囲のポートは、登録済みポートと呼ばれ、通常アプリケーションが自由に利用してよいポートである
    - サーバサイドのアプリケーションで用いられる
  - 49152–65535 の範囲のポートは、 動的・プライベート ポート番号 とよばれ、一時的な使用に用いられる
    - 基本的に送信時のエフェメラルポートとして利用され、サーバサイドのアプリケーションで用いられることはない
    - プロキシサーバなどでは、送信ポート数を潤沢にするためにエフェメラルポートの範囲を 10000–65535 のように変更して利用したりもする
