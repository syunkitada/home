# Resource

PCのリソースの利用状況や正常性、エラーをチェックするためのコマンド集です。

## sysstatのインストール
``` bash
$ sudo yum install sysstat
```


## uptime
``` bash
# 現在の時刻 up 起動時間, ログインユーザ数 user, load avelage: 1分, 5分, 30分
$ uptime
23:51:26 up 21:31,  1 user,  load average: 30.02, 26.43, 19.02
```

* 現在の時刻がずれている場合
dateでタイムゾーンをチェック
``` bash
$ date
2016年  2月 28日 日曜日 11:55:54 JST
```

ntpで時刻同期をチェック
``` bash
$ ntpq -p
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
 ntp.kiba.net    189.130.221.188  2 u   31   64    1   24.292   -0.229   0.000
 ec2-54-64-6-78. 133.243.238.164  2 u   31   64    1   17.889    0.627   0.000
```

ntpの設定をチェック
``` bash
$ vim -R /etc/ntp.conf
```

* 起動時間が短い場合
リブートした覚えがないのに、これが短い場合PCが何かの原因でリブートした可能性がある

* load avelage
load avelageとは、現在CPUが実行しているタスク数のこと。
つまり、CPUのスレッド数よりも大きい場合は、処理が間に合っていないことになる。

これには、割り込み不可能なIOでブロックされているプロセスも含まれているので、ディスクIOが間に合っていない場合などによくこの値が高くなる。

また、load avelageが、1分間、5分間、15分間の指数移動平均で表示されるので、負荷が時間経過とともにどのように変化したかがわかる。

15分間のload averageより、5, 1分間のload averageが非常に大きい場合、今現在なにかが起きている可能性がある。
また、5, 1分間のload averageが非常に少ない場合、今現在はなにも起きていないが、5～15分前になにか起きていた可能性がある。


## dmesg | less

``` bash
$ dmesg | less

[1880957.563150] perl invoked oom-killer: gfp_mask=0x280da, order=0, oom_score_adj=0
[...]
[1880957.563400] Out of memory: Kill process 18694 (perl) score 246 or sacrifice child
[1880957.563408] Killed process 18694 (perl) total-vm:1972392kB, anon-rss:1953348kB, file-rss:0kB
[2320864.954447] TCP: Possible SYN flooding on port 7001. Dropping request.  Check SNMP counters.
```
oom-killerとTCPのリクエストのドロップなど、エラーを含むシステムの情報を得ることができます。
なにか起きてると思ったらすぐにチェックすべき項目です。


## vmstat 1
``` bash
$ vmstat 1
procs ---------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0
32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0
32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0
32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0
32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0
^C
```

1秒間ごとに仮想メモリの統計を表示します。
一行目はシステム起動時からの平均。

r : CPUで実行中および順番を待っているプロセスの数。これはI/Oを含んでいないので、CPUの飽和状態を見るのに、ロードアベレージよりも良いシグナルになります。言い換えると、"r"の値がCPU数よりも多ければ飽和状態ということです。

free : キロバイトでの空きメモリー量。数えられないぐらいの桁数が表示されていたら、十分なメモリーがあります。7番目に出てくるfree -mコマンドは、空きメモリのより詳しい説明を表示してくれます。

si, so : スワップインとスワップアウト。ゼロでない値があれば、メモリ不足。

us, sy, id, wa, st : CPU時間の内訳で、すべてのCPUに対する平均値。それぞれ、ユーザ時間、システム(カーネル)時間、アイドル時間、I/O待ち時間、stealされた時間(他のゲストマシンや、Xenの場合ゲストの分離されたドライバードメインによるsteal)。


CPU時間の内訳で、userとsystem時間を足すことでCPUがビジーかどうか確認できるでしょう。I/O待ちが一定の数値を示しているならディスクがボトルネックです。この時、タスクはディスクI/O待ちでブロックされてしまうため、CPUはアイドル状態になってしまっています。従って、I/O待ちはCPUアイドル時間の別の形と考えられ、なぜアイドルなのかを調べる手がかりになり得ます。

システム時間は、I/O処理に必要です。20%を超えるような高いシステム時間は、詳しく調べる必要があると言えるでしょう。おそらくカーネルがI/Oを効率よく処理できていない状態です。

上の例では、CPU時間はほとんどユーザレベルになっており、つまりアプリケーションレベルが使用していることを示しています。CPUは平均90%以上使用されています。これは必ずしも問題とは言えず、「r」列で飽和状態の程度を調べましょう。


