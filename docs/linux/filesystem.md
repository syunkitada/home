# ファイルシステム


## ファイル
* ファイル読み書きのチャネル
    * ファイルをopenするとファイルディスクリプタ（ファイル記述子）を得る
* inode
    * ファイルがディスク上のどこにあるかを示す
    * その他のメタデータ
        * サイズ、使用ブロック数、リンク数のカウント、アクセス権限、UID、GID、タイムスタンプなど
    * inodeはディスク上にある(ファイルシステムによってはない)
        * これをメモリにキャッシュして使ってる
        * 基本的にはメモリ上にあるモノをinodeと呼んでいる
    * inodeは一つのファイルシステムごとに一意になる
    * inodeはstatコマンドで確認できる
        * 以下はその結果だが、ファイル名は実はinodeには保存されてない
        * ファイル名はディレクトリエントリで管理されている
```
$ stat README.md
  File: 'README.md'
  Size: 484             Blocks: 8          IO Block: 4096   騾壼ｸｸ繝輔ぃ繧､繝ｫ
Device: 801h/2049d      Inode: 1574959     Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/   owner)   Gid: ( 1000/   owner)
Access: 2017-12-17 21:29:50.091897601 +0900
Modify: 2017-12-17 21:29:50.091897601 +0900
Change: 2017-12-17 21:29:50.091897601 +0900
 Birth: -
```
* ファイルに関するシステムコール
    * open
    * read
    * write
    * see


## ディレクトリとディレクトリエントリ(dentry)
* ディレクトリとはファイル整理のためのデータベース、実態はdentry
* dentry
    * 実態はディスク上にあり、メモリにキャッシュして利用している
    * ファイル名の情報を持っており、inodeが紐づいている
* パスの解決
    * dentryをたどるとパスを解決できる
    * 相対パスも絶対パスも開始地点が違うだけで、たどり方は同じ


## ファイルディスクリプタとファイルオブジェクト
* プロセスごとにファイルディスクリプタテーブルがつくられる
    * ファイルディスクリプタテーブルとは、ファイルディスクリプタとファイルの対応表
* 複数のファイルディスクリプタで同一のファイルを操作することも可能
* ファイルディスクリプタ
    * dentryやシーク位置やフラグを管理してる
    * ファイルオブジェクトに紐づけられる
    * ファイルオブジェクトの先にファイルシステムがある
* ファイルディスクリプタとclone
    * 子プロセスを生成すると
        * ファイルディスクリプタテーブルだけコピーされる
        * ファイルオブジェクトはコピーされない
    * スレッドを生成すると
        * (指定がなければ)ファイルディスクリプタテーブルも共有する
* lsof
    * プロセスがopenしてるファイルを表示する
    * /proc/[pid]/fd を見てる
* パイプ
    * パイプを使うとファイルディスクリプタが2つできて間にリングバッファができて読み書きできる
* ネットワーク（ソケット）通信
    * ファイルディスクリプタ（ソケット)の先がネットワークのプロトコルスタックになってる
    *ソケット経由でプロセスはネットワーク通信を行う



## ブロックデバイス
* ランダムアクセス可能なデバイスをブロックデバイスとして抽象化している
    * ブロックの「アドレス」を指定して読み書きが可能
* MAJ:MIN
    * デバイスのメジャーバージョンとマイナーバージョン
    * 必要なデバイスドライバは、このバージョンから特定される
```
$ lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda     8:0    0 238.5G  0 disk
 sda1   8:1    0 222.6G  0 part /
 sda2   8:2    0     1K  0 part
 sda5   8:5    0  15.9G  0 part [SWAP]

# -Sでscsi関連の情報が出せる
$ lsblk -S
NAME HCTL       TYPE VENDOR   MODEL             REV TRAN
sda  0:0:0:0    disk ATA      TOSHIBA THNSNJ25 0101 sata
```

## ブロックデバイスとファイルシステム
* ブロックデバイスを「ブロック」に分割
    * 512バイト、1024バイト、4096バイト(x86_64はこれが限界)
* ファイルとブロックの対応関係を管理する
    * 対応関係自体もブロックデバイス上に記録する
    * ファイルシステムごとに、これをどのように記録するかが異なる
* ext2の場合
    * 最初にブロックデバイス上にinodeの領域を確保する
    * bitmapを持ち、各ブロックが使ってるかどうかを、true, faulseのbitのマップで管理している
    * inodeには、ブロックデバイスのどのブロックを参照するかが書かれている
        * inodeの参照テーブルが枯渇する場合は、間接参照用のテーブルが確保されてそこからブロックを参照する


## ページキャッシュ
* ページキャッシュをio request queueへ接続
    * リクエストから一定時間たてばディスクに書く
    * ページキャッシュのdirtyが上がったら書き込む(dirty_raitio)
    * ページキャッシュが一定量上がったら書き込む(dirty_bytes)
    * dirty_raitioとdirty_bytesは排他
        * dirty_raitioを書いたらdirty_bytesは0が書き込まれて無効になる
        * dirty_bytesを書いたらdirty_raitioは0が書き込まれて無効になる
    * io elevator(io scheduler)によって、並んだ書き込みやリクエストをマージする
        * cfq, deadline, noop
    * デバイスが高速なら、マージはあまり意味はないので、noop or deadlineでよい
* iostat -x 1
    * rrqm, wreqmがマージされた数
    * ddしながら見てみるとよい
* キューの長さを変える
    * echo 1024 > /sys/block/sda/queue/max_sectors_kb
* メモリが枯渇していて、キャッシュが確保できない時は、確保できるまでプロセスが止められる
* mount option: async
    * キャッシュに書いたら完了にして、非同期に書き込む
* mount option: sync
    * 同期的に書き込む
* aio write
    * IOリクエストしたらキャッシュに書いた時点で書き込み完了
    * そして、非同期に書き込んで、その結果(成功、失敗）をシグナルで受け取る


## mount


## nfs


## iscsi


## devicemapper


## loopback device




## メモ
* procをマウントする
    * mount -t proc abc /tmp/abc
* hachoir tests
    * バイナリファイルに対するwireshark
* ioctl [ファイルディスクリプタ] [デバイス]
    * デバイスによって挙動がいろいろ
    * kvmもこれで呼ばれる
* 基本的にkernel自体はioをすることはない（すべきでもない）
    * 例外
        * core dumpぐらい
    * swap in, swap out
    * モジュール読み込み、modprobはモジュールをメモリに読み込んでからカーネルに渡すので、カーネルはIOしない
* ディスク性能を計測するときはキャッシュを消してから行う
    * echo 1 > /proc/sys/vm/drop_caches
