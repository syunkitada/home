# プログラミングにおけるメモリ管理

## カーネルによるプログラムへのメモリ割り当て

- 仮想アドレス空間の大きさ
  - 32 ビットシステムで、0x00000000-0xffffffff
  - 64 ビットシステムで、0x00000000-0xffffffffffffffff (実際には、 もう少し小さい。0x00ffffffffffff くらい)
- プログラムは、起動すると仮想メモリ空間を作成し、そこに以下の情報をマッピングする(以下は 32bit の例)
  - 32 ビットシステムの範囲は、0x00000000-0xffffffff（4GB）
  - カーネル空間は、高い番地(0xffffffff)から低い番地(0xc0000000)を固定で割り当てており、残り(3GB)をユーザ空間で利用する
  - 引数、環境変数(カーネル空間に続いて、高い番地から低い番地へ固定で割り当てられる)
  - スタック(引数、環境変数の空間に続いて、高い番地から低い番地へ割り当てられ拡張されていく)
    - スタックポインタが指すところ
  - ヒープ(BSS 空間に続いて、低い番地から高い番地へ割り当てられ拡張されていく)
    - スタックとヒープのメモリ空間は連続していないので、互いに拡張できる
  - プログラムファイル(0 番値付近を空けて、低い番地から高い番地へ固定で割り当てられる)
    - 読み込み専用の機械語
    - PC がこの先頭を指し、プログラムが実行される
  - 0 番地(0x00000000)付近はメモリを割り当てないことが一般的
    - 割り込みのエントリポイントになってたりする?
- 仮想アドレスと RSS
  - プロセスが、上記の仮想アドレスにアクセスすると、まだページが存在しない場合(初めてアクセスしたときなど)、PageFault という例外が発生する
  - OS は、ユーザプログラムのアクセス先を調べて、mmap によって得た仮想アドレスの場合には先ほどの mmap の指定に従ってメモリを割り当てる
  - この実際に割り当てられた物理アドレスが RSS となる
- プログラムによって拡張されるのはスタックとヒープであり、メモリにおいて開発者が意識する必要があるのもこの二つである
  - 基本的にプログラミング言語側（一部を除いて）で意識しなくてもよいように設計されているが、高パフォーマンスを目指すなら意識する必要がある

## スタック

- 静的なメモリ割り当てで利用され、LIFO(Last In First Out)の構造を持っている
- LIFO の性質上データの保存と取得が高速
  - 必要な CPU 命令は、保存はスタックへの push 、取得はスタックからの pop だけ
- スタックに格納されるデータは有限で静的でなければならない（コンパイル時にデータのサイズが分ってる必要がある）
- 関数の実行データがスタックフレームとして格納される場所
  - 各フレームは、その機能に必要なデータが格納されるスペースのブロックです
  - 例えば、関数が新しい変数を宣言するたびに、その変数はスタックの最上位のブロックにプッシュされる
  - 次に、関数が終了するたびに最上位のブロックがクリアされる
  - これらは、ここに格納されているデータの性質により、コンパイル時に決定できる
- マルチスレッドアプリケーションは、スレッドごとにスタックを持つことができる
- スタックのメモリ管理は OS によって実行される

## ヒープ

- 動的なメモリ割り当てで利用される
- 割り当て方法はプログラミング言語に大きく依存しており、基本的にポインタを使用してヒープ内を検索する
  - スタックに比べて遅いが柔軟
- ヒープはスレッド間で共有される
- プログラム側でヒープ管理しないといけない言語
  - C、C++は、ヒープの管理をプログラム側に委ねており、malloc、free などをでメモリ割り当て、解放を行う必要がある

## ガベージコレクション（GC）

- いくつかのプログラミング言語は、ヒープを自動で管理しており、メモリの解放は GC という仕組みで行っている
  - JVM(Java/Scala/Groovy/Kotlin), JavaScript, C#, Golang, OCaml, Ruby など
- Mark & Sweep GC(Tracing GC とも言う)
  - 2 段階のアルゴリズム
    1. "alive"として参照されたまだ存在するオブジェクトをマークする
    2. "alive"でないオブジェクトのメモリを解放する
  - JVM, C#, Ruby, JavaScript, Golang はこのアプローチを利用している
  - V8 などの JavaScript エンジンは、Mark & Sweep GC と Reference counting GC を併用している
  - C, C++でも外部ライブラリとしてこのような GC を使用できる
- Reference counting GC
  - すべてのオブジェクトは参照カウントを得る
  - オブジェクトへの参照が変更されるとインクリメントまたはデクリメントされカウントがゼロになるとガベージコレクションが実行される
  - 循環参照は処理できない
  - PHP、Perl、Python は、このタイプの GC を回避策と共に使用して、循環参照を克服している

## Resource Acquisition is Initialization (RAII)

- オブジェクトのメモリ割り当ては、ライフタイムは構築から破棄までのライフタイムに関連付けられる
- 変数がスコープ外に出たときにそのデストラクタが呼び出されてリソースを開放する
  - これにより、手動でメモリを開放したり、メモリリークを心配する必要がなくなる
- これは C++で導入され、Ada や Rust でも使用されている

## Automatic Reference Counting(ARC)

- Reference counting GC に似ているが、特定の間隔でランタイムプロセスを実行する代わりに、保持及び解放命令がコンパイル時にコンパイルされたコードに挿入され、オブジェクト参照がゼロになると、プログラムを一時停止することなく実行の一部として自動的にクリアされる
- 循環参照を処理することはできず、t 九艇のキーワードを使用されて処理するために開発者に依存する
- これは Clang コンパイラの機能であり、Objective C, Swift に ARC を提供する

## Ownership

- RAII と所有権モデルの組み合わせ
- 値は所有者として（一度に一人の所有者のみ）変数を持つ必要がある
- 所有者がスコープ外になると、値は（スタックまたはヒープにあるかどうかに関係なく)ドロップされる
- これはコンパイル時の参照カウントのようなもの
- Rust によって利用されている

## TCMalloc

- TCMalloc のメモリ管理は thread memory と pageheap の 2 つのパートに分かれる
- thread memory
  - 32k 以下の小さいオブジェクトは、thread memory から割り当てられる
  - 各スレッドは、ロックなしの小さいオブジェクト用のキャッシュを持っている
    - スレッドごとにキャッシュがあるので、スレッド間でロックを取る必要がない
  - このキャッシュは、様々な固定サイズごとの割り当て可能なフリーリストでここからメモリを割り当てたり、解放を行う
    - Buddy システムの仕組みに近い
    - 8, 16, 32, 48, ,,, 256 バイトの各サイズごとのフリーリストがある
- page heap
  - 32K より大きいオブジェクトは、ページヒープから割り当てられる
  - TCMalloc によって管理されるヒープは、ページのコレクションであり、span として表される連続したページのセット

## Golang によるメモリ管理

- Go Runtime は各 Goroutines(G)を追跡して、Logical Processors(P)にスケジュールする
  - P は OS スレッド(M)の抽象化リソース（タスク、コンテキストと同等）とみなすことができる、
- スタック
  - G ごとにある静的なデータを保存するためのメモリ領域
  - GC は行われず、メモリ管理は OS によって行われ、利用コストも安い
- ヒープ(mheap)
  - Go が動的なメモリ管理で利用され、GC が行われる場所
  - 一つの mheap オブジェクトは、8KB のページで分割されて管理される
  - メモリが必要になると、mheap は arena と呼ばれる 64MB のチャンクとして仮想メモリを OS に要求する
    - 初期化時に 1arena 確保され、より多くのメモリが必要になると追加の arena 用の仮想メモリを OS に要求する
  - mcache
    - TCMalloc の thread memory と同様に P ごとにキャッシュ(mcache)を持つ
    - Goroutine がメモリを必要とすると、ロックなしで mcache から取得する
    - mcache は、各ブロックサイズ(spanClass)ごとの mspan を含んでいる
      - spanClass は、67 の異なるサイズに分かれ、そのサイズごとに mspan が存在する
      - mspan オブジェクトは、固定サイズのオブジェクトの double linked list になっている
      - mspan オブジェクトは、以下の情報を含む
        - spanClass: ブロックサイズ
        - startAddr: ページの開始アドレス
        - npages: ページ数
    - mspan への参照は、2 つのタイプをによって区別される
      - scan: ポインタを含むオブジェクト
      - noscan: ポインタを含まないオブジェクト
      - タイプを分けることで、GC の際に scan はトラバースする必要があるが、noscan はその必要がなくなる
  - mcentral
    - 同一サイズ spanClass ごとのグループで、各 mcentral は二つの mspanList を含む
      - empty: free でないオブジェクトや mcache にキャッシュされている span の double linked list で、span が free になったら、non-empty に移動される
      - non-empty: free の span の double linked list で、新しい span が要求されたら、ここから払い出して empty に移動する
  - mheap
    - mcentral のコレクション
    - 各 spanClass 用の mspan を持っており、新しい span が要求されたら、ここから払い出す
  - オブジェクトの割り当てフロー
    - Size > 32K: mheap から直接割り当てられる
    - Size < 16B: mcache の tiny から割り当てられる
    - 16B - 32K: 対応する size の spanClass の mcache から割り当てられる
    - もし、対応する spanClass の mcache に割り当て可能なブロックがない場合は、mcentral に要求する
    - もし、mcentral に利用可能な span がない場合は、mheap に要求し、最も一致する span を探して利用する
    - mheap に利用可能な span がない場合、新しいページセット(arena)をオペレーティングシステムに要求する
- エスケープ分析
  - Go コンパイラはエスケープ分析というプロセスを用いて、コンパイル時に寿命が wakat タイルオブジェクトを見つけ、ヒープではなくスタックに割り当てる
    - go build -gcflags '-m' フラグをつけて実行すると、その詳細を確認できる
    - 一部の Go ライブラリでは、この特性を考慮してなるべくスタックを利用するように設計されている
- Garbage collection
  - Mark Setup(Stop the world)
    - GC が開始されると、コレクタは次の同時実行フェーズの間にデータの整合性を維持するために書き込みバリアをオンにする
    - このステップでは、実行中のすべての Goroutine がこれを有効にするために一時停止してその後継続させる、非常に小さなポーズを必要とする
  - Marking(Concurrent)
    - 書き込みバリアがオンになると、実際のマーキングプロセスが開始され、アクティブな値がマークされる
      - これはそのアプリケーションと並行稼働し、利用可能な CPU キャパシティの 25%を利用する
      - マーキングが完了するまで、対応する P はリザーブされる
  - Mark Termination(Stop the world)
    - マーキングが終了すると、すべてのアクティブな Goroutine は一時停止し（非常に小さなポーズ）、書き込みバリアをオフにし、クリーンアップタスクが開始される
    - これが完了すると、リザーブされた P は、アプリケーションに戻され解放される
  - Sweeping(Concurrent)
    - マークされていないオブジェクトを reclaim (返還) する
- 参考
  - [Visualizing memory management in Golang](https://deepu.tech/memory-management-in-golang/)
    - [Go におけるメモリ管理の可視化](https://zenn.dev/kazu1029/articles/38ab3d99ef0de3)
      - Visualizing memory management in Golang の日本語訳
  - [A visual guide to Go Memory Allocator from scratch (Golang)](https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed)

## Rust によるメモリ管理

- Rust は、メモリモデルが定義されておらず、とても単純になっている
- Rust のプログラムは OS によって仮想メモリが割り当てられる
- スタック
  - スレッドごとにある静的なデータを管理するためのメモリ領域
- ヒープ
  - Ownership model によって動的なデータを管理するためのメモリ領域
  - 静的な値はすべてスタックに保存され、動的な値のデータはヒープ上に作成されスマートポインタを用いたスタックから参照される
- Ownership
  - スタック、ヒープに限らず以下のルールが適用される
    - すべての値は owner として変数を持つ
    - 値には常に一つの owner がいる
    - owner がスコープの外になると、その値はドロップされてメモリが解放される
  - これらのルールはコンパイル時にチェックされ、メモリの解放は RAII を利用してプログラムの実行時に行われるため、追加のオーバーヘッドや一時停止が発生しない
- Borrowing & Borrow checker
  - 変数を参照で渡すことを borrowing と呼ぶ
  - リソースの所有者は一度に一人しか持てないので、リソースの所有権を取らずに使用するにはリソースを borrowing する必要がある
  - Rust コンパイラは、参照が裕子言うなオブジェクトを指しているか、所有権のルールに違反していないかを静的に確認する Borrow checker を持っている
- スマートポインタ
  - RAII と同様で C++に導入された仕組み
  - 通常のポインタに加えてメタデータを持ち、スマートポインタは指し示すデータを所有する
- 参考
  - [Visualizing memory management in Rust](https://deepu.tech/memory-management-in-rust/)

## 参考

- [Demystifying memory management in modern programming languages](https://deepu.tech/memory-management-in-programming/)
