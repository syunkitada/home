# プロセスとスケジューラ


## プロセスとスレッド
* プロセスはプログラムの実行を管理するための箱
    * 実態はカーネル内のデータ構造
    * プロセスは、プロセスID(pid)を持っており、/proc/[pid]/ にそのプロセスのデータを見ることができる
* スレッドはプロセスの実行単位
    * スレッドとは、プロセスの実行単位で、スケジューラはこのスレッドの単位でスケジューリング(CPUの割り当て)を行う
    * /proc/[pid]/task/ にスレッド(プロセス)のデータ構造が格納されている
        * プロセスにはスレッドが必ず一つ以上含まれており、プログラムを実行したときに最初のスレッドが作成され、このスレッドのID(tid)がプロセスのpidとなる
        * スレッドを作成すると、task_structとmm_structが生成される
        * /proc/[pid]/task/[tid] にそのスレッドのデータを見ることができる
            * /proc/[tid]でも実は見れる
            * しかし、ls /procするとスレッド[tid]は表示されない
    * プロセスは少し抽象的な言い方で、スレッド単体の事をプロセスと呼ぶこともあるし、あるスレッドの子スレッドも含めた集合をプロセスと呼ぶこともある


## プロセスの親子関係
* プロセスは親子関係を持つ
* 新規のプロセスは基本的に1番(initプロセス)の子プロセスになる
    * 新規プロセスの中で子プロセスを生成することも可能
    * 全プロセスはinitプロセスを頂点としたツリー構造となる
        * pstreeコマンドで確認できる
* 新規のプロセス(子プロセス)は、clone()システムコールにより生成される
    * 昔はfork()システムコールで生成していたので、その名残で子プロセスの生成をforkと呼ぶこともある
    * cloneはスレッドも作れる


## カーネルスレッド
* カーネルが生成するスレッド
    * kthread, migration/0, ksoftirqd/0, watchdog/0, events/0 など
    * スレッドなので通常スレッドと同様にスケジューリングされるが、initには属していない
    * しかし、重要なスレッドなので実行の優先度が高く、スケジューリングされやすくなっている
* プロセス名には慣例として[]がついており、CPUごとに作成される場合には/0 のように数字がついてる
    * 例: [watchdog/0], [watchdog/1]
* カーネルでは今すぐに実行しなくてもよいタスクは、キューに登録しておき、別スレッドで登録されたタスクを実行している
    * トップハーフ: 今やらないといけない処理、タスクの登録などもする
    * ボトムハーフ: 非同期で処理していいもの、カーネルスレッドで処理する


## システムコールとlibc
* スレッドがシステムコールを呼び出すとき、通常はlibc(glibcなど)によってラップされた関数を利用する
* カーネルは番号でシステムコールを認識してる
* あるプログラムがどのようなシステムコールを読んでるかは、straceを実行すると見ることができる
    * strace [cmd]
        * コマンドをシステムコールをトレースする
        * システムコールがエラーを起こした場合、カーネルは理由を示すエラー値(整数、errno)を返す、Eから始まる名前がついてる
        * 例: strace ls
    * strace -e [systemcalls] [cmd]
        * システムコールをフィルタリングして表示する
        * 例: strace -e open,close ls
    * strace -p [pid]
        * 既存プロセスにアタッチしてトレースする
    * strace -f ...
        * 通常のトレースはそのスレッドのみをトレースするが、-fを付けるとスレッドが新たにスレッドやプロセスの作成したときにそのスレッドの処理もトレースする
    * strace -o [outputfile] ...
        * トレースの結果をファイルに書き出す
    * strace ... 2>&1 | less
        * トレースの結果をlessで見る
    * strace -t ...
        * タイムスタンプを表示する
* プロセス関連のシステムコール
    * fork
        * プロセスを生成する
    * clone
        * スレッドを作成する、プロセスを作成する
        * cloneはforkを汎用化したシステムコール
            * 親プロセスに割り当てられたリソースをコピーするよう指定するとプロセスを作成(forkと同じ動作)する
            * 親プロセスとリソースを共有するよう指定した場合、スレッドを作成する
            * glibcの内部ではfork関数を呼ぶと内部ではcloneを呼び出してる
    * execve
        * 現在のプロセス内で実行しているプログラムを指定したプログラムと置き換え、実行開始する
    * wait/wait4
        * cloneで作成した子プロセスの終了を待つ
    * exit
        * プロセスの終了、プロセスは終了ステータスだけを持つ状態になる
    * getpid, geteuid, getegrp
        * プロセスの基本的な情報取得
* プロセス生成の流れ
    * cloneでプロセスを作成する
    * execveでプログラムを実行する
        * execve時には実行するファイルのパス、引数、環境変数を指定する
    * プロセスはexitで終了し、終了ステータスだけを持つ状態になる(zonbi状態)
    * 親プロセスがwaitでこの終了ステータスを拾うとプロセスは消える
* 子プロセスが終了する前に親プロセスが終了すると、子プロセスはinitプロセスの子プロセスとなる
* man
    * man 1 strace
    * man 2 syscalls
    * man 2 syscall


## /proc/[pid]/の中身
* cmdline - プロセスのコマンドライン
* environ - 環境変数
* cwd - ワーキングディレクトリへのリンク
* exe - 実行したバイナリファイルへのリンク
* fd, fdinfo - ファイルディスクリプタ
* oom_adj, oom_score - OOMについての情報
* pagemap, maps, smaps, numa_maps - メモリ情報
* autogroup, cgroup, sessionid - プロセスグループの情報
* wchan - カーネル内で待機してる理由
* stack - カーネルスタック
* stat, statm, status - プロセスの統計情報


## スケジューラの仕組み(tick kernel)
* rhel5以前
* 定期的にスケジューラがタイマー割り込みで入り(tick)、次に実行するスレッドへコンテキストスイッチを実行する
    * この割り込みはCPUごとに行われるので、スケジューラはCPU単位で実行される
    * スケジューラはスレッドではなく、スケジューリング処理のことを指す

## スケジューラの仕組み(tickless kernel)
* rhel6以降
* システムコールが呼ばれたり、タイマー割り込みや、ハードウェア割り込みなどのイベントが発生すると、スケジューラが呼ばれる
    * このようなイベントはCPU単位で発生し、スケジューラもまたCPU単位で実行される
    * スケジューラはスレッドではなく、スケジューリング処理のことを指す
* スケジューラは呼ばれると、ロックをかけてそのCPUでスケジューリングが多重実行されないようにする
* スケジューラは次に実行すべきスレッドを決定し、ロックを外して、コンテキストスイッチを行う
* そして、またイベントが発生するとスケジューラが呼ばれ、次のスレッドがスケジューリングされて実行される
* イベントが発生するまではidleになる
    * しかし、c3_state(低消費電力状態)から動作再開には少し時間がかかる
    * c3_stateにならないようにするには、/dev/cpu_dma_latencyに0を書き込む

## コンテキストスイッチ
* CPUで実行するスレッドを切り替えること
    * コスト
        * 同一プロセス内の別スレッド間で切り替える場合
            * CPUのレジスタ内容を差し替える
    * 別プロセスのスレッド間で切り替える場合
        * CPUのレジスタの内容を差し替える
        * TLBの吐き出し、仮想アドレス空間(PageTable）を切り替える
* システムコールとCPUモード切替
    * システムコールや割り込みなどでカーネルの処理が必要になった場合
    * CPUの保護モードを特権モードに変更
    * カーネルスタックに切り替えたのち（通常の関数呼び出しと同様)スタックにレジスタを退避
    * カーネル上の必要な個所へジャンプして処理する
    * これはコンテキストスイッチではない
        * コンテキストスイッチはスレッドを切り替えることを指す


/proc/[pid]/sched
vruntimeが見れる

migrationスレッド

/proc/sys/kernel/sched_min_granularity_ns
* 最低でもこの時間だけCPUを連続して割り当てる


## mpstat
* プロセスがいない場合はidleに分類
* プロセスがいないけど、IO待ちがある場合はiowaitに分類される
* %guest ゲストで使ってるcpuの割合
* %steal ゲスト側からどのくらいcpu割り当てられなかったか
    * kernel同士で情報交換してる
```
$ mpstat 1
CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
all   10.05    0.00   40.20    0.00    0.00    0.00    0.00    0.00    0.00   49.75
all   12.06    0.00   38.19    0.00    0.00    0.00    0.00    0.00    0.00   49.75
```






