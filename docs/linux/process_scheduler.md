# プロセスとスケジューラ

## 目次

| Link                                                                                      | Description                                                                |
| ----------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| [プロセスとスレッド](#プロセスとスレッド)                                                 | プロセス、スレッド、カーネルスレッド、/proc/[pid]の中身                    |
| [システムコール](#システムコール)                                                         | システムコール、CPU のモード切り替え、strace、プロセス関連のシステムコール |
| [スケジューラの仕組み](#スケジューラの仕組み)                                             | tick kernel、tickless kerne、スケジューリングポリシー、CFS                 |
| [mpstat](#mpstat)                                                                         | mpstat コマンドの見方                                                      |
| [プロセスとスケジュラ関連のカーネルスレッド](#プロセスとスケジュラ関連のカーネルスレッド) | watchdog, khungtaskd, migration                                            |
| [割り込み](#割り込み)                                                                     | 同期割り込み、非同期割り込み                                               |

## プロセスとスレッド

- プロセスはプログラムの実行を管理するための箱
  - 実態はカーネル内のデータ構造
  - プロセスは、プロセス ID(pid)を持っており、/proc/[pid]/ にそのプロセスのデータを見ることができる
- スレッドはプロセスの実行単位
  - スレッドとは、プロセスの実行単位で、スケジューラはこのスレッドの単位でスケジューリング(CPU の割り当て)を行う
  - /proc/[pid]/task/ にスレッド(プロセス)のデータ構造が格納されている
    - プロセスにはスレッドが必ず一つ以上含まれており、プログラムを実行したときに最初のスレッドが作成され、このスレッドの ID(tid)がプロセスの pid となる
    - スレッドを作成すると、task_struct と mm_struct が生成される
    - /proc/[pid]/task/[tid] にそのスレッドのデータを見ることができる
      - /proc/[tid]でも実は見れる
      - しかし、ls /proc するとスレッド[tid]は表示されない
  - プロセスは少し抽象的な言い方で、スレッド単体の事をプロセスと呼ぶこともあるし、あるスレッドの子スレッドも含めた集合をプロセスと呼ぶこともある
- プロセスの親子関係
  - プロセスは親子関係を持つ
  - 新規のプロセスは基本的に 1 番(init プロセス)の子プロセスになる
    - 新規プロセスの中で子プロセスを生成することも可能
    - 全プロセスは init プロセスを頂点としたツリー構造となる
      - pstree コマンドで確認できる
  - 新規のプロセス(子プロセス)は、clone()システムコールにより生成される
    - 昔は fork()システムコールで生成していたので、その名残で子プロセスの生成を fork と呼ぶこともある
    - clone はスレッドも作れる
- スレッドの状態
  - R: CPU 実行中、CPU 割り当て待ち
  - S: 割り込み可能なイベント待ち
    - network, pipe など
    - kill などでシグナル送れる
  - D: 割り込み不かなイベント待ち
    - disk io など
  - T: stopped/traced, シグナル(Ctrl+z)やデバッガで一時停止中
  - Z: 実行終了後は終了、親プロセスへ渡す終了ステータスだけ維持
    - 親がこれを取らないと、残り続ける
  - X: 終了、ほぼ観測できない
- カーネルスレッド
  - カーネルが生成するスレッド
    - kthread, migration/0, ksoftirqd/0, watchdog/0, events/0 など
    - スレッドなので通常スレッドと同様にスケジューリングされるが、init には属していない
    - しかし、重要なスレッドなので実行の優先度が高く、スケジューリングされやすくなっている
  - プロセス名には慣例として[]がついており、CPU ごとに作成される場合には/0 のように数字がついてる
    - 例: [watchdog/0], [watchdog/1]
    - CPU ごとに作成されるカーネルスレッド
      - https://www.kernel.org/doc/Documentation/kernel-per-CPU-kthreads.txt
  - カーネルでは今すぐに実行しなくてもよいタスクは、キューに登録しておき、別スレッドで登録されたタスクを実行している
    - トップハーフ: 今やらないといけない処理、タスクの登録などもする
    - ボトムハーフ: 非同期で処理していいもの、カーネルスレッドで処理する
- /proc/[pid]/の中身
  - cmdline - プロセスのコマンドライン
  - environ - 環境変数
  - cwd - ワーキングディレクトリへのリンク
  - exe - 実行したバイナリファイルへのリンク
  - fd, fdinfo - ファイルディスクリプタ
  - oom_adj, oom_score - OOM についての情報
  - pagemap, maps, smaps, numa_maps - メモリ情報
  - autogroup, cgroup, sessionid - プロセスグループの情報
  - wchan - カーネル内で待機してる理由
  - stack - カーネルスタック
  - stat, statm, status - プロセスの統計情報

## システムコール

- スレッドがシステムコールを呼び出すとき、通常は libc(glibc など)によってラップされた関数を利用する
- カーネルは番号でシステムコールを認識してる
- CPU のモード切替
  - システムコールや割り込みなどでカーネルの処理が必要になった場合、CPU の保護モードを特権モードに変更
  - その後、カーネルスタックに切り替えたのち（通常の関数呼び出しと同様)スタックにレジスタを退避し、カーネル上の必要な個所へジャンプして処理する
  - ちなみに、これはコンテキストスイッチとは言わない
    - コンテキストスイッチはスレッドを切り替えることを指す
- あるプログラムがどのようなシステムコールを読んでるかは、strace を実行すると見ることができる
  - strace [cmd]
    - コマンドをシステムコールをトレースする
    - システムコールがエラーを起こした場合、カーネルは理由を示すエラー値(整数、errno)を返す、E から始まる名前がついてる
    - 例: strace ls
  - strace -e [systemcalls][cmd]
    - システムコールをフィルタリングして表示する
    - 例: strace -e open,close ls
  - strace -p [pid]
    - 既存プロセスにアタッチしてトレースする
  - strace -f ...
    - 通常のトレースはそのスレッドのみをトレースするが、-f を付けるとスレッドが新たにスレッドやプロセスの作成したときにそのスレッドの処理もトレースする
  - strace -o [outputfile] ...
    - トレースの結果をファイルに書き出す
  - strace ... 2>&1 | less
    - トレースの結果を less で見る
  - strace -t ...
    - タイムスタンプを表示する
- プロセス関連のシステムコール
  - fork
    - プロセスを生成する
  - clone
    - スレッドを作成する、プロセスを作成する
    - clone は fork を汎用化したシステムコール
      - 親プロセスに割り当てられたリソースをコピーするよう指定するとプロセスを作成(fork と同じ動作)する
      - 親プロセスとリソースを共有するよう指定した場合、スレッドを作成する
      - glibc の内部では fork 関数を呼ぶと内部では clone を呼び出してる
  - execve
    - 現在のプロセス内で実行しているプログラムを指定したプログラムと置き換え、実行開始する
  - wait/wait4
    - clone で作成した子プロセスの終了を待つ
  - exit
    - プロセスの終了、プロセスは終了ステータスだけを持つ状態になる
  - getpid, geteuid, getegrp
    - プロセスの基本的な情報取得
- プロセス生成の流れ
  - clone でプロセスを作成する
  - execve でプログラムを実行する
    - execve 時には実行するファイルのパス、引数、環境変数を指定する
  - プロセスは exit で終了し、終了ステータスだけを持つ状態になる(zonbi 状態)
  - 親プロセスが wait でこの終了ステータスを拾うとプロセスは消える
- 子プロセスが終了する前に親プロセスが終了すると、子プロセスは init プロセスの子プロセスとなる
- man
  - man 1 strace
  - man 2 syscalls
  - man 2 syscall

## スケジューラの仕組み

- tick kernel
  - centos5 以前
  - 定期的にスケジューラがタイマー割り込みで入り(tick)、次に実行するスレッドへコンテキストスイッチを実行する
    - この割り込みは CPU ごとに行われるので、スケジューラは CPU 単位で実行される
    - スケジューラはスレッドではなく、スケジューリング処理のことを指す
- tickless kernel
  - centos6 以降
  - システムコールが呼ばれたり、タイマー割り込みや、ハードウェア割り込みなどのイベントが発生すると、スケジューラが呼ばれる
    - このようなイベントは CPU 単位で発生し、スケジューラもまた CPU 単位で実行される
    - スケジューラはスレッドではなく、スケジューリング処理のことを指す
  - スケジューラは呼ばれると、ロックをかけてその CPU でスケジューリングが多重実行されないようにする
  - スケジューラは次に実行すべきスレッドを決定し、ロックを外して、コンテキストスイッチを行う
  - そして、またイベントが発生するとスケジューラが呼ばれ、次のスレッドがスケジューリングされて実行される
  - イベントが発生するまでは idle になる
    - しかし、c3_state(低消費電力状態)から動作再開には少し時間がかかる
    - c3_state にならないようにするには、/dev/cpu_dma_latency に 0 を書き込む
- コンテキストスイッチ
  - CPU で実行するスレッドを切り替えること
    - 同一プロセス内の別スレッド間で切り替える場合
      - CPU のレジスタ内容を差し替える
    - 別プロセスのスレッド間で切り替える場合(コストが高い)
      - CPU のレジスタの内容を差し替える
      - TLB の吐き出し、仮想アドレス空間(PageTable）を切り替える
- スレッドはキューに積まれる
  - CPU ごとに run キューがあり、実行可能なスレッドは run キューに積まれる
  - IO の要求などでディスクなどの IO 待ちの場合は、IO 待ち用の wait キューに積まれる
- スケジューリングポリシー
  - top の PR の項目を見るとプロセスの優先度、スケジューリングポリシーがわかる
  - スケジューリングポリシーは大きく、リアルタイムポリシーと通常のポリシーに分けられる
    - 最初にリアルタイムスレッドがスケジュールされ、すべてのリアルタイムスレッドの後で通常のスレッドがスケジュールされる
    - カーネルスレッドは重要度が高く、リアルタイムスレッドであることがよくある
  - リアルタイムポリシー
    - SCHED_FIFO
      - 実行可能で、優先度が一番高いスレッドをスケジュールする
    - SCHED_RR
      - SCHED_FIFO と同じだが、与えられた quantum を消費すると停止する
  - 通常ポリシー
    - SCHED_OTHER(or SCHED_NORMAL)
      - デフォルト
      - CFS を使ってこのポリシーを利用するすべてのスレッドに対して公平なスケジューリングを行う
    - SCHED_BATCH
      - CPU 時間を付与するが、I/O 待ちによる優先度上昇なし
    - SCHED_IDLE
      - 他に実行すべきスレッドがない時にのみスケジューリングする
  - chrt コマンド、sched_setscheduler システムコールで設定できる
- CFS(Completely Fair Scheduler)
  - centos6 以降で使われてるスケジューラ
  - スケジュール期間(period)を実行可能なスレッド間で分割し、その時間(slice)をスレッドに割り当てる
    - 優先度の高いスレッドに slice を多めに割り当てる
    - period = スレッド数 \* sched_min_granularity_ns
  - vruntime が最も小さいスレッドを選択してスレッドを割り当てる
    - vruntime は、/proc/[pid]/sched に書かれてる
    - 直近の割り当てが sched_min_granularity_ns を下回るときは、スケジューリングしない（再度同じスレッドに CPU を割り当てる)
    - /proc/sys/kernel/sched_min_granularity_ns
      - 大きくするとバッチ処理向き
      - 小さくすると対話処理向き
    - /proc/[pid]/schedstat
      - スケジューリングに関する統計情報
- スケジューラ関連のシステムコール
  - nice
    - プロセスの優先度を設定
  - sched_yield
    - 自分から CPU を手放したい時にスケジューラを明示的に呼び出す
    - 他に cpu 実行したいスレッドがいなければまた自分スレッドが割り当てられる
  - sched_setscheduler, sched_getscheduler
    - スケジューリングポリシーを設定する
  - sched_setaffinity, sched_getaffinity
    - スレッドが動作可能な CPU のセットを設定する

## mpstat

- %idle プロセスがいない場合は idle に分類
- %iowait プロセスがいないけど、IO 待ちがある場合は iowait に分類される
- %guest ゲストで使ってる cpu の割合
- %steal ゲスト側からどのくらい cpu 割り当てられなかったか(ゲスト、ホスト間で情報交換して計算してる)
- %user ユーザプロセスを実行していた時間
- %system カーネルの実行していた時間
- %nice 優先度を下げたプロセスを実行していた時間
- %irq 非同期割り込みの処理時間(hardware interrupt)
- %softirq softiq の処理時間(software interrupt)

```
$ mpstat 1
CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
all   10.05    0.00   40.20    0.00    0.00    0.00    0.00    0.00    0.00   49.75
all   12.06    0.00   38.19    0.00    0.00    0.00    0.00    0.00    0.00   49.75
```

## プロセスとスケジュラ関連のカーネルスレッド

- watchdog カーネルスレッド
  - スケジューラが正しく動いてるかをチェックするカーネルスレッド
  - 「BUG: soft lockup - CPU#0 stuck for 30s!..」というログについて
    - 同じスレッドがずっと同じ CPU に割り当てられていると、スケジューラのバグではと watchdog が判断してこのログが出る
    - 仮想環境でよくある
    - vcpu にスレッドが割り当てられたが、vcpu 自体のスレッドに物理 CPU が割り当てられてないと、vcpu はその間実行できず、スレッドも割り当て状態となる
      - そして次に vcpu に物理 CPU が割り当てられた際に、同じ vcpu に同じスレッドがずっと割り当てられてると watchdog が勘違いする
- khungtaskd カーネルスレッド
  - ブロックされてハングアップしたプロセスを定期巡回して、プロセスのスタックダンプを取る
  - 「INFO: task ... blocked for more than 120 seconds.」というログについて
    - スレッドが割り込み禁止状態のまま 120 秒以上経過してると、何かおかしいのではと、このログが出る
    - メッセージにスタックトレースも出力されるので、待ち状態のスレッドが何を待っているのかを確認するとよい
- migration カーネルスレッド
  - migration とはスレッドを実行する CPU を変更すること、これを行うのが migration カーネルスレッド
  - /proc/<pid>/sched の se.nr_migrations を見るとそのスレッドが何回マイグレーションされたかわかる
  - コスト設定(/proc/sys/kernel/sched_migration_cost_ns を設定)することで、その時間を使うではマイグレーションしないようになる
  - スレッドが配置可能な CPU を制御することができる
    - /proc/[pid]/status の Cpu_allowd で確認できる
    - numactl や taskset、sched_setaffinity システムコールで設定できる

## 割り込み

- 割り込みには番号があり、割り込みが発生すると CPU はその番号に対応するハンドラを実行する
  - cat /proc/interrupts で割り込み番号、処理回数を確認できる
- 割り込みハンドラはカーネルが設定する
- 非同期割り込み
  - CPU 外のハードウェアから通知される割り込み
  - タイマー割り込み
  - HDD の DMA 転送が終わった
  - Ethernet カードがパケットを受信した
- 同期割り込み(例外)

  - ゼロで除算した
  - アクセス許可のないメモリにアクセスしようとした
  - 特権がないのに特権命令を実行した

- 割り込みのカウンタを確認

```
$ cat /proc/interrupts
           CPU0       CPU1
  0:         18          0   IO-APIC   2-edge      timer
  1:          2          0   IO-APIC   1-edge      i8042
  8:          1          0   IO-APIC   8-edge      rtc0
  9:          0          0   IO-APIC   9-fasteoi   acpi
 12:          4          0   IO-APIC  12-edge      i8042
 16:         26          3   IO-APIC  16-fasteoi   ehci_hcd:usb1
```

- 割り込み処理を割り込みハンドラですべて動的に処理すると、遅延してしまうので、実施すべき処理を登録だけしてあとはスケジューラに任せる
- この登録した処理を softirq と呼び、CPU ごとにこれを実行するスレッド(ksoftirqd)が用意されている

```
$ ps ax | grep ksoftirqd
  3 ? S 0:00 [ksoftirqd/0]
  13 ? S 0:00 [ksoftirqd/1]

$ cat /proc/softirqs
CPU0 CPU1
HI: 3 2
TIMER: 1246628 2315450
NET_TX: 1 14868
NET_RX: 22540 209467
BLOCK: 19536 500141
BLOCK_IOPOLL: 0 0
TASKLET: 58 333
SCHED: 1240211 2250434
HRTIMER: 0 0
RCU: 682194 2333117

```

## ハードウェア割り込み

- IO APCI による割り込み
  - 割り込みは CPU ごとに存在する Local APIC(Advanced Programmable Interrupt Controller)と呼ばれる割り込みコントローラと、ICH(South bridge)に内蔵される IO APIC によって実現される
  - IO APIC は、PCI デバイスからの割り込みを受け取り、IO APIC の設定に基づいて割り込みを Local APIC にリダイレクトする
  - Local APIC は割り込み用のレジスタにアクセスされると、CPU にその割り込みの種類に応じたハンドラを実行させる
  - この割り込みハンドラは、IDT(Interrupt Descriptor Table)と呼ばれ最大 255 エントリのテーブルで管理されており、1 エントリには 0-255 のベクタ番号と、ハンドラのアドレスを格納している
  - IDT はメモリ上に展開され、そのアドレスを IDTR レジスタに格納することで CPU から参照される
- MSI/MSIX による割り込み
  - IO APIC によるデバイス割り込みはあまり使われていない
  - IO APIC を経由する PCI デバイス割り込みは、各 PCI デバイスからの物理的な割り込み線を利用するため、ひとつのデバイスで複数の割り込みを持つことができなかった
  - そこで、PCI バス経由のメッセージとして割り込みを送る Message Signalled Interrupt(MSI)、Extended MSI(MSI-X)が導入された
  - これらは、IO-APIC を経由せずに直接 Local APIC へ配送される
  - この時の宛先 CPU の設定は各 PCI デバイスの Configuration Space の Destination ID に設定される

## 内部割込みと外部割込み

- 内部割込みとは、CPU 内部の要因で発生する割り込みの事で、ソフトウェア割り込み(スーパーバイザコール割り込み)と、例外(プログラム割り込みとも呼ばれる)に分類される
  - ソフトウェア割り込みとは、システムコールなどで使われる INT 命令による割り込みのこと
  - 例外割込みとは、ゼロ除算・オーバーフロー・無効な命令の実行・ページフォルトなどが発生したときにおこる割り込みのこと
- 外部割込みとは、ハードウェアから CPU へ「キーボードが押された」などのイベント通知を行うのに用いられる
  - 外部割込みは、マスク可能な割り込みと、ソフトウェアからマスク可能な割り込み(NMI)の 2 種類に分かれる
    - マスク可能な通常のデバイスから割り込みに用いられる
    - NMI はハードウェア障害の通知などの特殊な用途に用いられる

```

```
