# プロセスとスケジューラ


## 目次
| Link | Description |
| --- | --- |
| [プロセスとスレッド](#プロセスとスレッド)                                                 | プロセス、スレッド、カーネルスレッド、/proc/[pid]の中身 |
| [システムコール](#システムコール)                                                         | システムコール、CPUのモード切り替え、strace、プロセス関連のシステムコール |
| [スケジューラの仕組み](#スケジューラの仕組み)                                             | tick kernel、tickless kerne、スケジューリングポリシー、CFS |
| [mpstat](#mpstat)                                                                         | mpstatコマンドの見方 |
| [プロセスとスケジュラ関連のカーネルスレッド](#プロセスとスケジュラ関連のカーネルスレッド) | watchdog, khungtaskd, migration |


## プロセスとスレッド
* プロセスはプログラムの実行を管理するための箱
    * 実態はカーネル内のデータ構造
    * プロセスは、プロセスID(pid)を持っており、/proc/[pid]/ にそのプロセスのデータを見ることができる
* スレッドはプロセスの実行単位
    * スレッドとは、プロセスの実行単位で、スケジューラはこのスレッドの単位でスケジューリング(CPUの割り当て)を行う
    * /proc/[pid]/task/ にスレッド(プロセス)のデータ構造が格納されている
        * プロセスにはスレッドが必ず一つ以上含まれており、プログラムを実行したときに最初のスレッドが作成され、このスレッドのID(tid)がプロセスのpidとなる
        * スレッドを作成すると、task_structとmm_structが生成される
        * /proc/[pid]/task/[tid] にそのスレッドのデータを見ることができる
            * /proc/[tid]でも実は見れる
            * しかし、ls /procするとスレッド[tid]は表示されない
    * プロセスは少し抽象的な言い方で、スレッド単体の事をプロセスと呼ぶこともあるし、あるスレッドの子スレッドも含めた集合をプロセスと呼ぶこともある
* プロセスの親子関係
    * プロセスは親子関係を持つ
    * 新規のプロセスは基本的に1番(initプロセス)の子プロセスになる
        * 新規プロセスの中で子プロセスを生成することも可能
        * 全プロセスはinitプロセスを頂点としたツリー構造となる
            * pstreeコマンドで確認できる
    * 新規のプロセス(子プロセス)は、clone()システムコールにより生成される
        * 昔はfork()システムコールで生成していたので、その名残で子プロセスの生成をforkと呼ぶこともある
        * cloneはスレッドも作れる
* スレッドの状態
    * R: CPU実行中、CPU割り当て待ち
    * S: 割り込み可能なイベント待ち
        * network, pipeなど
        * killなどでシグナル送れる
    * D: 割り込み不かなイベント待ち
        * disk ioなど
    * T: stopped/traced, シグナル(Ctrl+z)やデバッガで一時停止中
    * Z: 実行終了後は終了、親プロセスへ渡す終了ステータスだけ維持
        * 親がこれを取らないと、残り続ける
    * X: 終了、ほぼ観測できない
* カーネルスレッド
    * カーネルが生成するスレッド
        * kthread, migration/0, ksoftirqd/0, watchdog/0, events/0 など
        * スレッドなので通常スレッドと同様にスケジューリングされるが、initには属していない
        * しかし、重要なスレッドなので実行の優先度が高く、スケジューリングされやすくなっている
    * プロセス名には慣例として[]がついており、CPUごとに作成される場合には/0 のように数字がついてる
        * 例: [watchdog/0], [watchdog/1]
    * カーネルでは今すぐに実行しなくてもよいタスクは、キューに登録しておき、別スレッドで登録されたタスクを実行している
        * トップハーフ: 今やらないといけない処理、タスクの登録などもする
        * ボトムハーフ: 非同期で処理していいもの、カーネルスレッドで処理する
* /proc/[pid]/の中身
    * cmdline - プロセスのコマンドライン
    * environ - 環境変数
    * cwd - ワーキングディレクトリへのリンク
    * exe - 実行したバイナリファイルへのリンク
    * fd, fdinfo - ファイルディスクリプタ
    * oom_adj, oom_score - OOMについての情報
    * pagemap, maps, smaps, numa_maps - メモリ情報
    * autogroup, cgroup, sessionid - プロセスグループの情報
    * wchan - カーネル内で待機してる理由
    * stack - カーネルスタック
    * stat, statm, status - プロセスの統計情報


## システムコール
* スレッドがシステムコールを呼び出すとき、通常はlibc(glibcなど)によってラップされた関数を利用する
* カーネルは番号でシステムコールを認識してる
* CPUのモード切替
    * システムコールや割り込みなどでカーネルの処理が必要になった場合、CPUの保護モードを特権モードに変更
    * その後、カーネルスタックに切り替えたのち（通常の関数呼び出しと同様)スタックにレジスタを退避し、カーネル上の必要な個所へジャンプして処理する
    * ちなみに、これはコンテキストスイッチとは言わない
        * コンテキストスイッチはスレッドを切り替えることを指す
* あるプログラムがどのようなシステムコールを読んでるかは、straceを実行すると見ることができる
    * strace [cmd]
        * コマンドをシステムコールをトレースする
        * システムコールがエラーを起こした場合、カーネルは理由を示すエラー値(整数、errno)を返す、Eから始まる名前がついてる
        * 例: strace ls
    * strace -e [systemcalls] [cmd]
        * システムコールをフィルタリングして表示する
        * 例: strace -e open,close ls
    * strace -p [pid]
        * 既存プロセスにアタッチしてトレースする
    * strace -f ...
        * 通常のトレースはそのスレッドのみをトレースするが、-fを付けるとスレッドが新たにスレッドやプロセスの作成したときにそのスレッドの処理もトレースする
    * strace -o [outputfile] ...
        * トレースの結果をファイルに書き出す
    * strace ... 2>&1 | less
        * トレースの結果をlessで見る
    * strace -t ...
        * タイムスタンプを表示する
* プロセス関連のシステムコール
    * fork
        * プロセスを生成する
    * clone
        * スレッドを作成する、プロセスを作成する
        * cloneはforkを汎用化したシステムコール
            * 親プロセスに割り当てられたリソースをコピーするよう指定するとプロセスを作成(forkと同じ動作)する
            * 親プロセスとリソースを共有するよう指定した場合、スレッドを作成する
            * glibcの内部ではfork関数を呼ぶと内部ではcloneを呼び出してる
    * execve
        * 現在のプロセス内で実行しているプログラムを指定したプログラムと置き換え、実行開始する
    * wait/wait4
        * cloneで作成した子プロセスの終了を待つ
    * exit
        * プロセスの終了、プロセスは終了ステータスだけを持つ状態になる
    * getpid, geteuid, getegrp
        * プロセスの基本的な情報取得
* プロセス生成の流れ
    * cloneでプロセスを作成する
    * execveでプログラムを実行する
        * execve時には実行するファイルのパス、引数、環境変数を指定する
    * プロセスはexitで終了し、終了ステータスだけを持つ状態になる(zonbi状態)
    * 親プロセスがwaitでこの終了ステータスを拾うとプロセスは消える
* 子プロセスが終了する前に親プロセスが終了すると、子プロセスはinitプロセスの子プロセスとなる
* man
    * man 1 strace
    * man 2 syscalls
    * man 2 syscall


## スケジューラの仕組み
* tick kernel
    * centos5以前
    * 定期的にスケジューラがタイマー割り込みで入り(tick)、次に実行するスレッドへコンテキストスイッチを実行する
        * この割り込みはCPUごとに行われるので、スケジューラはCPU単位で実行される
        * スケジューラはスレッドではなく、スケジューリング処理のことを指す
* tickless kernel
    * centos6以降
    * システムコールが呼ばれたり、タイマー割り込みや、ハードウェア割り込みなどのイベントが発生すると、スケジューラが呼ばれる
        * このようなイベントはCPU単位で発生し、スケジューラもまたCPU単位で実行される
        * スケジューラはスレッドではなく、スケジューリング処理のことを指す
    * スケジューラは呼ばれると、ロックをかけてそのCPUでスケジューリングが多重実行されないようにする
    * スケジューラは次に実行すべきスレッドを決定し、ロックを外して、コンテキストスイッチを行う
    * そして、またイベントが発生するとスケジューラが呼ばれ、次のスレッドがスケジューリングされて実行される
    * イベントが発生するまではidleになる
        * しかし、c3_state(低消費電力状態)から動作再開には少し時間がかかる
        * c3_stateにならないようにするには、/dev/cpu_dma_latencyに0を書き込む
* コンテキストスイッチ
    * CPUで実行するスレッドを切り替えること
        * 同一プロセス内の別スレッド間で切り替える場合
            * CPUのレジスタ内容を差し替える
        * 別プロセスのスレッド間で切り替える場合(コストが高い)
            * CPUのレジスタの内容を差し替える
            * TLBの吐き出し、仮想アドレス空間(PageTable）を切り替える
* スレッドはキューに積まれる
    * CPUごとにrunキューがあり、実行可能なスレッドはrunキューに積まれる
    * IOの要求などでディスクなどのIO待ちの場合は、IO待ち用のwaitキューに積まれる
* スケジューリングポリシー
    * topのPRの項目を見るとプロセスの優先度、スケジューリングポリシーがわかる
    * スケジューリングポリシーは大きく、リアルタイムポリシーと通常のポリシーに分けられる
        * 最初にリアルタイムスレッドがスケジュールされ、すべてのリアルタイムスレッドの後で通常のスレッドがスケジュールされる
        * カーネルスレッドは重要度が高く、リアルタイムスレッドであることがよくある
    * リアルタイムポリシー
        * SCHED_FIFO
            * 実行可能で、優先度が一番高いスレッドをスケジュールする
        * SCHED_RR
            * SCHED_FIFOと同じだが、与えられたquantumを消費すると停止する
    * 通常ポリシー
        * SCHED_OTHER(or SCHED_NORMAL)
            * デフォルト
            * CFSを使ってこのポリシーを利用するすべてのスレッドに対して公平なスケジューリングを行う
        * SCHED_BATCH
            * CPU時間を付与するが、I/O待ちによる優先度上昇なし
        * SCHED_IDLE
            * 他に実行すべきスレッドがない時にのみスケジューリングする
    * chrtコマンド、sched_setschedulerシステムコールで設定できる
* CFS(Completely Fair Scheduler)
    * centos6 以降で使われてるスケジューラ
    * スケジュール期間(period)を実行可能なスレッド間で分割し、その時間(slice)をスレッドに割り当てる
        * 優先度の高いスレッドにsliceを多めに割り当てる
        * period = スレッド数 * sched_min_granularity_ns
    * vruntimeが最も小さいスレッドを選択してスレッドを割り当てる
        * vruntimeは、/proc/[pid]/sched に書かれてる
        * 直近の割り当てがsched_min_granularity_nsを下回るときは、スケジューリングしない（再度同じスレッドにCPUを割り当てる)
        * /proc/sys/kernel/sched_min_granularity_ns
            * 大きくするとバッチ処理向き
            * 小さくすると対話処理向き
        * /proc/[pid]/schedstat
            * スケジューリングに関する統計情報
* スケジューラ関連のシステムコール
    * nice
        * プロセスの優先度を設定
    * sched_yield
        * 自分からCPUを手放したい時にスケジューラを明示的に呼び出す
        * 他にcpu実行したいスレッドがいなければまた自分スレッドが割り当てられる
    * sched_setscheduler, sched_getscheduler
       * スケジューリングポリシーを設定する
    * sched_setaffinity, sched_getaffinity
        * スレッドが動作可能なCPUのセットを設定する


## mpstat
* %idle プロセスがいない場合はidleに分類
* %iowait プロセスがいないけど、IO待ちがある場合はiowaitに分類される
* %guest ゲストで使ってるcpuの割合
* %steal ゲスト側からどのくらいcpu割り当てられなかったか(ゲスト、ホスト間で情報交換して計算してる)
* %user ユーザプロセスを実行していた時間
* %system カーネルの実行していた時間
* %nice 優先度を下げたプロセスを実行していた時間
* %irq 非同期割り込みの処理時間(hardware interrupt)
* %softirq softiqの処理時間(software interrupt)
```
$ mpstat 1
CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
all   10.05    0.00   40.20    0.00    0.00    0.00    0.00    0.00    0.00   49.75
all   12.06    0.00   38.19    0.00    0.00    0.00    0.00    0.00    0.00   49.75
```


## プロセスとスケジュラ関連のカーネルスレッド
* watchdog カーネルスレッド
    * スケジューラが正しく動いてるかをチェックするカーネルスレッド
    * 「BUG: soft lockup - CPU#0 stuck for 30s!..」というログについて
        * 同じスレッドがずっと同じCPUに割り当てられていると、スケジューラのバグではとwatchdogが判断してこのログが出る
        * 仮想環境でよくある
        * vcpuにスレッドが割り当てられたが、vcpu自体のスレッドに物理CPUが割り当てられてないと、vcpuはその間実行できず、スレッドも割り当て状態となる
            * そして次にvcpuに物理CPUが割り当てられた際に、同じvcpuに同じスレッドがずっと割り当てられてるとwatchdogが勘違いする
* khungtaskd カーネルスレッド
    * ブロックされてハングアップしたプロセスを定期巡回して、プロセスのスタックダンプを取る
    * 「INFO: task ... blocked for more than 120 seconds.」というログについて
        * スレッドが割り込み禁止状態のまま120秒以上経過してると、何かおかしいのではと、このログが出る
        * メッセージにスタックトレースも出力されるので、待ち状態のスレッドが何を待っているのかを確認するとよい
* migration カーネルスレッド
    * migrationとはスレッドを実行するCPUを変更すること、これを行うのがmigration カーネルスレッド
    * /proc/<pid>/schedのse.nr_migrationsを見るとそのスレッドが何回マイグレーションされたかわかる
    * コスト設定(/proc/sys/kernel/sched_migration_cost_nsを設定)することで、その時間を使うではマイグレーションしないようになる
    * スレッドが配置可能なCPUを制御することができる
        * /proc/[pid]/statusのCpu_allowdで確認できる
        * numactlやtaskset、sched_setaffinityシステムコールで設定できる
